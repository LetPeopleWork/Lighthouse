name: Generate Appcast

on:
  schedule:
    - cron: '0 */6 * * *'
  workflow_dispatch:

jobs:
  check-release:
    runs-on: ubuntu-latest
    if: github.repository == 'LetPeopleWork/Lighthouse'
    outputs:
      proceed: ${{ steps.tags.outputs.proceed }}
      release_tags: ${{ steps.tags.outputs.release_tags }}
      latest_tag: ${{ steps.tags.outputs.latest_tag }}

    steps:
      - name: Check whether appcast already exists
        id: check
        run: |
          URL="https://github.com/LetPeopleWork/Lighthouse/releases/latest/download/appcast.xml"
          echo "Checking $URL"
          # Follow redirects and check final HTTP status code and final URL
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" -L "$URL" || echo "000")
          FINAL_URL=$(curl -s -o /dev/null -w "%{url_effective}" -L "$URL" || echo "")
          echo "Final URL: $FINAL_URL"
          echo "HTTP status: $STATUS"
          if [ "$STATUS" -eq 200 ]; then
            echo "Appcast already exists — nothing to do"
            echo "proceed=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "Appcast not found — proceeding"
          echo "proceed=true" >> $GITHUB_OUTPUT

      - name: Install jq
        if: steps.check.outputs.proceed == 'true'
        run: |
          sudo apt-get update && sudo apt-get install -y jq

      - name: Get latest releases
        id: tags
        if: steps.check.outputs.proceed == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get latest 5 non-prerelease tags as comma-separated list
          RELEASE_TAGS=$(curl -s -H "Authorization: token $GH_TOKEN" https://api.github.com/repos/LetPeopleWork/Lighthouse/releases | jq -r '.[] | select(.prerelease==false) | .tag_name' | head -5 | paste -sd ',' -)

          if [ -z "$RELEASE_TAGS" ] || [ "$RELEASE_TAGS" = "," ]; then
            echo "No non-prerelease releases found, skipping"
            echo "release_tags=" >> $GITHUB_OUTPUT
            echo "latest_tag=" >> $GITHUB_OUTPUT
            echo "proceed=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          LATEST_TAG=$(echo "$RELEASE_TAGS" | cut -d',' -f1)

          # Check whether any of the latest tags have a .app.zip asset; if not, we don't need to create appcast
          FOUND_APP="false"
          for TAG in $(echo "$RELEASE_TAGS" | tr ',' '\n'); do
            ASSET_NAMES=$(curl -s -H "Authorization: token $GH_TOKEN" https://api.github.com/repos/LetPeopleWork/Lighthouse/releases/tags/$TAG | jq -r '.assets[].name // empty') || true
            if echo "$ASSET_NAMES" | grep -Ei '\.app\.zip$' >/dev/null; then
              echo "Found .app.zip for tag: $TAG"
              FOUND_APP="true"
              break
            fi
          done

          if [ "$FOUND_APP" != "true" ]; then
            echo "No .app.zip assets found for latest releases; nothing to do"
            echo "release_tags=" >> $GITHUB_OUTPUT
            echo "latest_tag=" >> $GITHUB_OUTPUT
            echo "proceed=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "release_tags=$RELEASE_TAGS" >> $GITHUB_OUTPUT
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "proceed=true" >> $GITHUB_OUTPUT

  appcast:
    needs: check-release
    runs-on: macos-latest
    if: github.repository == 'LetPeopleWork/Lighthouse' && needs.check-release.outputs.proceed == 'true'

    permissions:
      contents: write

    env:
      GH_TOKEN: ${{ github.token }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8

      - name: Prepare release tags
        run: |
          mkdir -p updates
          echo "${{ needs.check-release.outputs.release_tags }}" | tr ',' '\n' > release_tags.txt
          echo "LATEST_TAG=${{ needs.check-release.outputs.latest_tag }}" >> $GITHUB_ENV
          cat release_tags.txt

      - name: Install GitHub CLI
        run: |
          brew install gh

      - name: Install jq
        run: |
          brew install jq      

      - name: Get latest releases
        run: |
          mkdir -p updates
          # release_tags.txt already provided by 'check-release' job
          if [ ! -s release_tags.txt ]; then
            echo "No non-prerelease releases found, skipping appcast generation"
            exit 0
          fi

      - name: Install Pandoc
        run: |
          brew install pandoc

      - name: Install Sparkle
        run: |
          echo "Installing Sparkle..."
          brew install sparkle
          
          # Sparkle tools are not always linked to PATH by the cask
          # Find where they are and add to GITHUB_PATH
          SPARKLE_BIN_DIR=$(find /opt/homebrew/Caskroom/sparkle -name sign_update -type f -print -quit | xargs dirname)
          if [ -z "$SPARKLE_BIN_DIR" ]; then
            SPARKLE_BIN_DIR=$(find /usr/local/Caskroom/sparkle -name sign_update -type f -print -quit | xargs dirname)
          fi
          
          if [ -n "$SPARKLE_BIN_DIR" ]; then
            echo "Found Sparkle tools at $SPARKLE_BIN_DIR"
            chmod +x "$SPARKLE_BIN_DIR"/*
            echo "$SPARKLE_BIN_DIR" >> $GITHUB_PATH
          else
            echo "Could not find Sparkle tools"
            exit 1
          fi

      - name: Download app bundles and create notes
        run: |
          # Helper: EdDSA (Sparkle 2) signing
          get_signature() {
            local zip_file="$1"
            # Sparkle 2 expects a 32-byte seed (Base64 encoded).
            # If the secret is 64 bytes (seed + public key), we extract the first 32 bytes.
            local seed=$(python3 -c "import base64; import sys; data = base64.b64decode(sys.argv[1].strip()); print(base64.b64encode(data[:32]).decode())" "${{ secrets.SPARKLE_PRIVATE_KEY }}")
            
            # Run sign_update using stdin for the key to avoid keychain issues in CI
            # -p: only print the signature
            # --ed-key-file -: read key from stdin
            local sig=$(echo "$seed" | sign_update -p --ed-key-file - "$zip_file" 2>/dev/null | tr -d '\n\r ')
            
            if [[ -n "$sig" && "$sig" =~ ^[A-Za-z0-9+/=]{80,90}$ ]]; then
              echo "$sig"
              return 0
            fi
            
            echo "ERROR: sign_update failed to produce a valid signature for $zip_file" >&2
            # Debug: show actual output without suppression
            echo "$seed" | sign_update --ed-key-file - "$zip_file" || true
            return 1
          }

          if [ ! -f release_tags.txt ]; then
            echo "No releases to process"
            exit 0
          fi
          mkdir -p updates/app
          rm -f updates/app/manifest.csv
          while IFS= read -r tag; do
            if [ -z "$tag" ]; then continue; fi
            echo "Processing release $tag"
            # Find any .app.zip asset for this release
            ASSET_NAME=$(gh release view "$tag" --json assets --jq '.assets[].name' | grep -E '\.app\.zip$' | head -1)
            if [ -n "$ASSET_NAME" ]; then
              echo "App bundle zip found for $tag: $ASSET_NAME, downloading..."
              gh release download "$tag" --pattern "$ASSET_NAME" --dir updates/app/
              ZIP_PATH="updates/app/$ASSET_NAME"
              # Sign the zip
              if ! get_signature "$ZIP_PATH" >/dev/null; then
                echo "Signing failed for $ZIP_PATH"
                exit 1
              fi

              # Get release body and create HTML notes (one notes file per tag)
              RELEASE_BODY=$(gh api repos/LetPeopleWork/Lighthouse/releases/tags/"$tag" | jq -r '.body')
              NOTES_FILE="updates/notes-${tag}.html"
              if [ "$RELEASE_BODY" != "null" ] && [ -n "$RELEASE_BODY" ]; then
                echo "$RELEASE_BODY" | pandoc -f markdown -t html > "$NOTES_FILE"
              else
                echo "<p>No release notes available.</p>" > "$NOTES_FILE"
              fi

              # Record mapping of tag -> asset name for later appcast generation
              echo "${tag},${ASSET_NAME}" >> updates/app/manifest.csv
            else
              echo "No .app.zip found for $tag, skipping..."
            fi
          done < release_tags.txt

      - name: Generate appcast
        run: |
          # Helper: EdDSA (Sparkle 2) signing
          get_signature() {
            local zip_file="$1"
            # Sparkle 2 expects a 32-byte seed (Base64 encoded).
            local seed=$(python3 -c "import base64; import sys; data = base64.b64decode(sys.argv[1].strip()); print(base64.b64encode(data[:32]).decode())" "${{ secrets.SPARKLE_PRIVATE_KEY }}")
            
            # Run sign_update using stdin for the key to avoid keychain issues in CI
            local sig=$(echo "$seed" | sign_update -p --ed-key-file - "$zip_file" 2>/dev/null | tr -d '\n\r ')
            
            if [[ -n "$sig" && "$sig" =~ ^[A-Za-z0-9+/=]{80,90}$ ]]; then
              echo "$sig"
              return 0
            fi
            
            echo "ERROR: sign_update failed to produce a valid signature for $zip_file" >&2
            return 1
          }

          if [ ! -f release_tags.txt ]; then
            echo "No releases to process"
            exit 0
          fi
          # Generate appcast XML with real data
          cat > appcast.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle" xmlns:dc="http://purl.org/dc/elements/1.1/">
            <channel>
              <title>Lighthouse</title>
              <description>Most recent changes with links to updates.</description>
              <language>en</language>
          EOF
          
          # Use manifest mapping (tag -> asset) if available
          if [ -f updates/app/manifest.csv ]; then
            while IFS=, read -r tag asset; do
              if [ -z "$tag" ] || [ -z "$asset" ]; then continue; fi
              ZIP_PATH="updates/app/${asset}"
              if [ -f "$ZIP_PATH" ]; then
                RELEASE_INFO=$(gh api repos/LetPeopleWork/Lighthouse/releases/tags/"$tag")
                TITLE=$(echo "$RELEASE_INFO" | jq -r .name)
                PUB_DATE=$(echo "$RELEASE_INFO" | jq -r .published_at | sed 's/T/ /' | sed 's/Z//' | xargs -I {} date -j -f "%Y-%m-%d %H:%M:%S" {} +"%a, %d %b %Y %H:%M:%S +0000")
                BODY_HTML=$(cat "updates/notes-${tag}.html" 2>/dev/null || echo "<p>No notes</p>")
                URL="https://github.com/LetPeopleWork/Lighthouse/releases/download/${tag}/${asset}"
                SIGNATURE=$(get_signature "$ZIP_PATH")
                if [ -z "$SIGNATURE" ]; then
                  echo "Failed to get signature for $ZIP_PATH"
                  exit 1
                fi
                LENGTH=$(stat -f%z "$ZIP_PATH")
                
                cat >> appcast.xml << EOF
                <item>
                  <title>$TITLE</title>
                  <sparkle:version>$tag</sparkle:version>
                  <sparkle:shortVersionString>$tag</sparkle:shortVersionString>
                  <description><![CDATA[$BODY_HTML]]></description>
                  <pubDate>$PUB_DATE</pubDate>
                  <enclosure url="$URL" sparkle:version="$tag" sparkle:edSignature="$SIGNATURE" length="$LENGTH" type="application/octet-stream"/>
                </item>
          EOF
              fi
            done < updates/app/manifest.csv
          else
            # Fallback: look for zip files matching tag in updates/app/
            while IFS= read -r tag; do
              if [ -z "$tag" ]; then continue; fi
              ZIP_PATH=$(ls updates/app/*"${tag}"*.app.zip 2>/dev/null | head -1)
              if [ -f "$ZIP_PATH" ]; then
                ASSET=$(basename "$ZIP_PATH")
                RELEASE_INFO=$(gh api repos/LetPeopleWork/Lighthouse/releases/tags/"$tag")
                TITLE=$(echo "$RELEASE_INFO" | jq -r .name)
                PUB_DATE=$(echo "$RELEASE_INFO" | jq -r .published_at | sed 's/T/ /' | sed 's/Z//' | xargs -I {} date -j -f "%Y-%m-%d %H:%M:%S" {} +"%a, %d %b %Y %H:%M:%S +0000")
                BODY_HTML=$(cat "updates/notes-${tag}.html" 2>/dev/null || echo "<p>No notes</p>")
                URL="https://github.com/LetPeopleWork/Lighthouse/releases/download/${tag}/${ASSET}"
                SIGNATURE=$(get_signature "$ZIP_PATH")
                if [ -z "$SIGNATURE" ]; then
                  echo "Failed to get signature for $ZIP_PATH"
                  exit 1
                fi
                LENGTH=$(stat -f%z "$ZIP_PATH")
                
                cat >> appcast.xml << EOF
                <item>
                  <title>$TITLE</title>
                  <sparkle:version>$tag</sparkle:version>
                  <sparkle:shortVersionString>$tag</sparkle:shortVersionString>
                  <description><![CDATA[$BODY_HTML]]></description>
                  <pubDate>$PUB_DATE</pubDate>
                  <enclosure url="$URL" sparkle:version="$tag" sparkle:edSignature="$SIGNATURE" length="$LENGTH" type="application/octet-stream"/>
                </item>
          EOF
              fi
            done < release_tags.txt
          fi
          
          cat >> appcast.xml << 'EOF'
            </channel>
          </rss>
          EOF

      - name: Upload appcast to latest release
        run: |
          if [ ! -f appcast.xml ]; then
            echo "No appcast.xml to upload"
            exit 0
          fi
          gh release upload "$LATEST_TAG" appcast.xml --clobber