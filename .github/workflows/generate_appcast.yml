name: Generate Appcast

on:
  release:
    types: [published]
  workflow_dispatch:

jobs:
  appcast:
    runs-on: macos-latest
    if: github.repository == 'LetPeopleWork/Lighthouse'

    permissions:
      contents: write

    env:
      GH_TOKEN: ${{ github.token }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install GitHub CLI
        run: |
          brew install gh

      - name: Install Pandoc
        run: |
          brew install pandoc

      - name: Install jq
        run: |
          brew install jq

      - name: Install Rosetta
        run: |
          softwareupdate --install-rosetta --agree-to-license

      - name: Download Sparkle tools
        run: |
          SPARKLE_VERSION="2.6.3"
          curl -L "https://github.com/sparkle-project/Sparkle/releases/download/${SPARKLE_VERSION}/Sparkle-${SPARKLE_VERSION}.tar.xz" -o sparkle.tar.xz
          tar -xf sparkle.tar.xz
          cd Sparkle-${SPARKLE_VERSION}
          sudo cp bin/generate_appcast /usr/local/bin/
          sudo cp bin/sign_update /usr/local/bin/
          sudo chmod +x /usr/local/bin/generate_appcast
          sudo chmod +x /usr/local/bin/sign_update

      - name: Prepare private key
        run: |
          echo "${{ secrets.SPARKLE_PRIVATE_KEY }}" | base64 -d > private_key.pem
          chmod 600 private_key.pem

      - name: Get latest releases
        run: |
          mkdir -p updates
          # Get latest 5 non-prerelease tags
          RELEASE_TAGS=$(gh api repos/LetPeopleWork/Lighthouse/releases --jq '.[] | select(.prerelease == false) | .tag_name' | head -5)
          if [ -z "$RELEASE_TAGS" ]; then
            echo "No non-prerelease releases found, skipping appcast generation"
            exit 0
          fi
          echo "$RELEASE_TAGS" > release_tags.txt
          LATEST_TAG=$(echo "$RELEASE_TAGS" | head -1)
          echo "LATEST_TAG=$LATEST_TAG" >> $GITHUB_ENV

          cat release_tags.txt

      - name: Download DMGs and create notes
        run: |
          if [ ! -f release_tags.txt ]; then
            echo "No releases to process"
            exit 0
          fi
          mkdir -p updates/dmg
          rm -f updates/dmg/manifest.csv
          while IFS= read -r tag; do
            if [ -z "$tag" ]; then continue; fi
            echo "Processing release $tag"
            # Find any DMG asset for this release (be flexible with naming)
            ASSET_NAME=$(gh release view "$tag" --json assets --jq '.assets[].name' | grep -E '\.dmg$' | head -1)
            if [ -n "$ASSET_NAME" ]; then
              echo "DMG found for $tag: $ASSET_NAME, downloading..."
              gh release download "$tag" --pattern "$ASSET_NAME" --dir updates/dmg/
              DMG_PATH="updates/dmg/$ASSET_NAME"
              # Sign the DMG
              sign_update "$DMG_PATH" private_key.pem

              # Get release body and create HTML notes (one notes file per tag)
              RELEASE_BODY=$(gh api repos/LetPeopleWork/Lighthouse/releases/tags/"$tag" | jq -r '.body')
              NOTES_FILE="updates/notes-${tag}.html"
              if [ "$RELEASE_BODY" != "null" ] && [ -n "$RELEASE_BODY" ]; then
                echo "$RELEASE_BODY" | pandoc -f markdown -t html > "$NOTES_FILE"
              else
                echo "<p>No release notes available.</p>" > "$NOTES_FILE"
              fi

              # Record mapping of tag -> asset name for later appcast generation
              echo "${tag},${ASSET_NAME}" >> updates/dmg/manifest.csv
            else
              echo "No DMG found for $tag, skipping..."
            fi
          done < release_tags.txt

      - name: Generate appcast
        run: |
          if [ ! -f release_tags.txt ]; then
            echo "No releases to process"
            exit 0
          fi
          # Generate appcast XML with real data
          cat > appcast.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle" xmlns:dc="http://purl.org/dc/elements/1.1/">
            <channel>
              <title>Lighthouse</title>
              <description>Most recent changes with links to updates.</description>
              <language>en</language>
          EOF
          
          # Use manifest mapping (tag -> asset) if available
          if [ -f updates/dmg/manifest.csv ]; then
            while IFS=, read -r tag asset; do
              if [ -z "$tag" ] || [ -z "$asset" ]; then continue; fi
              DMG_PATH="updates/dmg/${asset}"
              if [ -f "$DMG_PATH" ]; then
                RELEASE_INFO=$(gh api repos/LetPeopleWork/Lighthouse/releases/tags/"$tag")
                TITLE=$(echo "$RELEASE_INFO" | jq -r .name)
                PUB_DATE=$(echo "$RELEASE_INFO" | jq -r .published_at | sed 's/T/ /' | sed 's/Z//' | xargs -I {} date -j -f "%Y-%m-%d %H:%M:%S" {} +"%a, %d %b %Y %H:%M:%S +0000")
                BODY_HTML=$(cat "updates/notes-${tag}.html" 2>/dev/null || echo "<p>No notes</p>")
                URL="https://github.com/LetPeopleWork/Lighthouse/releases/download/${tag}/${asset}"
                SIGNATURE=$(sign_update "$DMG_PATH" private_key.pem 2>/dev/null)
                LENGTH=$(stat -f%z "$DMG_PATH")
                
                cat >> appcast.xml << EOF
                <item>
                  <title>$TITLE</title>
                  <sparkle:version>$tag</sparkle:version>
                  <sparkle:shortVersionString>$tag</sparkle:shortVersionString>
                  <description><![CDATA[$BODY_HTML]]></description>
                  <pubDate>$PUB_DATE</pubDate>
                  <enclosure url="$URL" sparkle:version="$tag" sparkle:edSignature="$SIGNATURE" length="$LENGTH" type="application/octet-stream"/>
                </item>
          EOF
              fi
            done < updates/dmg/manifest.csv
          else
            # Fallback: look for dmg files matching tag in updates/dmg/
            while IFS= read -r tag; do
              if [ -z "$tag" ]; then continue; fi
              DMG_PATH=$(ls updates/dmg/*"${tag}"*.dmg 2>/dev/null | head -1)
              if [ -f "$DMG_PATH" ]; then
                ASSET=$(basename "$DMG_PATH")
                RELEASE_INFO=$(gh api repos/LetPeopleWork/Lighthouse/releases/tags/"$tag")
                TITLE=$(echo "$RELEASE_INFO" | jq -r .name)
                PUB_DATE=$(echo "$RELEASE_INFO" | jq -r .published_at | sed 's/T/ /' | sed 's/Z//' | xargs -I {} date -j -f "%Y-%m-%d %H:%M:%S" {} +"%a, %d %b %Y %H:%M:%S +0000")
                BODY_HTML=$(cat "updates/notes-${tag}.html" 2>/dev/null || echo "<p>No notes</p>")
                URL="https://github.com/LetPeopleWork/Lighthouse/releases/download/${tag}/${ASSET}"
                SIGNATURE=$(sign_update "$DMG_PATH" private_key.pem 2>/dev/null)
                LENGTH=$(stat -f%z "$DMG_PATH")
                
                cat >> appcast.xml << EOF
                <item>
                  <title>$TITLE</title>
                  <sparkle:version>$tag</sparkle:version>
                  <sparkle:shortVersionString>$tag</sparkle:shortVersionString>
                  <description><![CDATA[$BODY_HTML]]></description>
                  <pubDate>$PUB_DATE</pubDate>
                  <enclosure url="$URL" sparkle:version="$tag" sparkle:edSignature="$SIGNATURE" length="$LENGTH" type="application/octet-stream"/>
                </item>
          EOF
              fi
            done < release_tags.txt
          fi
          
          cat >> appcast.xml << 'EOF'
            </channel>
          </rss>
          EOF

      - name: Upload appcast to latest release
        run: |
          if [ ! -f appcast.xml ]; then
            echo "No appcast.xml to upload"
            exit 0
          fi
          gh release upload "$LATEST_TAG" appcast.xml --clobber