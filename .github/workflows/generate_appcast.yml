name: Generate Appcast

on:
  release:
    types: [published]
  workflow_dispatch:

jobs:
  appcast:
    runs-on: macos-latest
    if: github.repository == 'LetPeopleWork/Lighthouse'

    permissions:
      contents: write

    env:
      GH_TOKEN: ${{ github.token }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install GitHub CLI
        run: |
          brew install gh

      - name: Install Pandoc
        run: |
          brew install pandoc

      - name: Install jq
        run: |
          brew install jq

      - name: Install Sparkle
        run: |
          echo "Installing Sparkle..."
          brew install sparkle
          
          # Sparkle tools are not always linked to PATH by the cask
          # Find where they are and add to GITHUB_PATH
          SPARKLE_BIN_DIR=$(find /opt/homebrew/Caskroom/sparkle -name sign_update -type f -print -quit | xargs dirname)
          if [ -z "$SPARKLE_BIN_DIR" ]; then
            SPARKLE_BIN_DIR=$(find /usr/local/Caskroom/sparkle -name sign_update -type f -print -quit | xargs dirname)
          fi
          
          if [ -n "$SPARKLE_BIN_DIR" ]; then
            echo "Found Sparkle tools at $SPARKLE_BIN_DIR"
            chmod +x "$SPARKLE_BIN_DIR"/*
            echo "$SPARKLE_BIN_DIR" >> $GITHUB_PATH
          else
            echo "Could not find Sparkle tools"
            exit 1
          fi

      - name: Get latest releases
        run: |
          mkdir -p updates
          # Get latest 5 non-prerelease tags
          RELEASE_TAGS=$(gh api repos/LetPeopleWork/Lighthouse/releases --jq '.[] | select(.prerelease == false) | .tag_name' | head -5)
          if [ -z "$RELEASE_TAGS" ]; then
            echo "No non-prerelease releases found, skipping appcast generation"
            exit 0
          fi
          echo "$RELEASE_TAGS" > release_tags.txt
          LATEST_TAG=$(echo "$RELEASE_TAGS" | head -1)
          echo "LATEST_TAG=$LATEST_TAG" >> $GITHUB_ENV

          cat release_tags.txt

      - name: Download DMGs and create notes
        run: |
          # Helper: EdDSA (Sparkle 2) signing
          get_signature() {
            local dmg="$1"
            # Clean the key of any whitespace/newlines
            local key=$(echo "${{ secrets.SPARKLE_PRIVATE_KEY }}" | tr -d '\n\r ')
            
            # Run sign_update and capture only the last line (the signature)
            local sig=$(sign_update -s "$key" "$dmg" 2>/dev/null | tail -n 1 | tr -d '\n\r ')
            
            # Validate that it looks like a base64 signature (approx 88 chars for Ed25519)
            if [[ -n "$sig" && "$sig" =~ ^[A-Za-z0-9+/=]{80,90}$ ]]; then
              echo "$sig"
              return 0
            fi
            
            echo "ERROR: sign_update failed to produce a valid signature for $dmg" >&2
            # Show actual error in logs for debugging
            sign_update -s "$key" "$dmg" || true
            return 1
          }

          if [ ! -f release_tags.txt ]; then
            echo "No releases to process"
            exit 0
          fi
          mkdir -p updates/dmg
          rm -f updates/dmg/manifest.csv
          while IFS= read -r tag; do
            if [ -z "$tag" ]; then continue; fi
            echo "Processing release $tag"
            # Find any DMG asset for this release (be flexible with naming)
            ASSET_NAME=$(gh release view "$tag" --json assets --jq '.assets[].name' | grep -E '\.dmg$' | head -1)
            if [ -n "$ASSET_NAME" ]; then
              echo "DMG found for $tag: $ASSET_NAME, downloading..."
              gh release download "$tag" --pattern "$ASSET_NAME" --dir updates/dmg/
              DMG_PATH="updates/dmg/$ASSET_NAME"
              # Sign the DMG (try native then Rosetta)
              if ! get_signature "$DMG_PATH" >/dev/null; then
                echo "Signing failed for $DMG_PATH"
                exit 1
              fi

              # Get release body and create HTML notes (one notes file per tag)
              RELEASE_BODY=$(gh api repos/LetPeopleWork/Lighthouse/releases/tags/"$tag" | jq -r '.body')
              NOTES_FILE="updates/notes-${tag}.html"
              if [ "$RELEASE_BODY" != "null" ] && [ -n "$RELEASE_BODY" ]; then
                echo "$RELEASE_BODY" | pandoc -f markdown -t html > "$NOTES_FILE"
              else
                echo "<p>No release notes available.</p>" > "$NOTES_FILE"
              fi

              # Record mapping of tag -> asset name for later appcast generation
              echo "${tag},${ASSET_NAME}" >> updates/dmg/manifest.csv
            else
              echo "No DMG found for $tag, skipping..."
            fi
          done < release_tags.txt

      - name: Generate appcast
        run: |
          # Helper: EdDSA (Sparkle 2) signing
          get_signature() {
            local dmg="$1"
            # Clean the key of any whitespace/newlines
            local key=$(echo "${{ secrets.SPARKLE_PRIVATE_KEY }}" | tr -d '\n\r ')
            
            # Run sign_update and capture only the last line (the signature)
            local sig=$(sign_update -s "$key" "$dmg" 2>/dev/null | tail -n 1 | tr -d '\n\r ')
            
            # Validate that it looks like a base64 signature
            if [[ -n "$sig" && "$sig" =~ ^[A-Za-z0-9+/=]{80,90}$ ]]; then
              echo "$sig"
              return 0
            fi
            
            echo "ERROR: sign_update failed to produce a valid signature for $dmg" >&2
            return 1
          }

          if [ ! -f release_tags.txt ]; then
            echo "No releases to process"
            exit 0
          fi
          # Generate appcast XML with real data
          cat > appcast.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle" xmlns:dc="http://purl.org/dc/elements/1.1/">
            <channel>
              <title>Lighthouse</title>
              <description>Most recent changes with links to updates.</description>
              <language>en</language>
          EOF
          
          # Use manifest mapping (tag -> asset) if available
          if [ -f updates/dmg/manifest.csv ]; then
            while IFS=, read -r tag asset; do
              if [ -z "$tag" ] || [ -z "$asset" ]; then continue; fi
              DMG_PATH="updates/dmg/${asset}"
              if [ -f "$DMG_PATH" ]; then
                RELEASE_INFO=$(gh api repos/LetPeopleWork/Lighthouse/releases/tags/"$tag")
                TITLE=$(echo "$RELEASE_INFO" | jq -r .name)
                PUB_DATE=$(echo "$RELEASE_INFO" | jq -r .published_at | sed 's/T/ /' | sed 's/Z//' | xargs -I {} date -j -f "%Y-%m-%d %H:%M:%S" {} +"%a, %d %b %Y %H:%M:%S +0000")
                BODY_HTML=$(cat "updates/notes-${tag}.html" 2>/dev/null || echo "<p>No notes</p>")
                URL="https://github.com/LetPeopleWork/Lighthouse/releases/download/${tag}/${asset}"
                SIGNATURE=$(get_signature "$DMG_PATH")
                if [ -z "$SIGNATURE" ]; then
                  echo "Failed to get signature for $DMG_PATH"
                  exit 1
                fi
                LENGTH=$(stat -f%z "$DMG_PATH")
                
                cat >> appcast.xml << EOF
                <item>
                  <title>$TITLE</title>
                  <sparkle:version>$tag</sparkle:version>
                  <sparkle:shortVersionString>$tag</sparkle:shortVersionString>
                  <description><![CDATA[$BODY_HTML]]></description>
                  <pubDate>$PUB_DATE</pubDate>
                  <enclosure url="$URL" sparkle:version="$tag" sparkle:edSignature="$SIGNATURE" length="$LENGTH" type="application/octet-stream"/>
                </item>
          EOF
              fi
            done < updates/dmg/manifest.csv
          else
            # Fallback: look for dmg files matching tag in updates/dmg/
            while IFS= read -r tag; do
              if [ -z "$tag" ]; then continue; fi
              DMG_PATH=$(ls updates/dmg/*"${tag}"*.dmg 2>/dev/null | head -1)
              if [ -f "$DMG_PATH" ]; then
                ASSET=$(basename "$DMG_PATH")
                RELEASE_INFO=$(gh api repos/LetPeopleWork/Lighthouse/releases/tags/"$tag")
                TITLE=$(echo "$RELEASE_INFO" | jq -r .name)
                PUB_DATE=$(echo "$RELEASE_INFO" | jq -r .published_at | sed 's/T/ /' | sed 's/Z//' | xargs -I {} date -j -f "%Y-%m-%d %H:%M:%S" {} +"%a, %d %b %Y %H:%M:%S +0000")
                BODY_HTML=$(cat "updates/notes-${tag}.html" 2>/dev/null || echo "<p>No notes</p>")
                URL="https://github.com/LetPeopleWork/Lighthouse/releases/download/${tag}/${ASSET}"
                SIGNATURE=$(get_signature "$DMG_PATH")
                if [ -z "$SIGNATURE" ]; then
                  echo "Failed to get signature for $DMG_PATH"
                  exit 1
                fi
                LENGTH=$(stat -f%z "$DMG_PATH")
                
                cat >> appcast.xml << EOF
                <item>
                  <title>$TITLE</title>
                  <sparkle:version>$tag</sparkle:version>
                  <sparkle:shortVersionString>$tag</sparkle:shortVersionString>
                  <description><![CDATA[$BODY_HTML]]></description>
                  <pubDate>$PUB_DATE</pubDate>
                  <enclosure url="$URL" sparkle:version="$tag" sparkle:edSignature="$SIGNATURE" length="$LENGTH" type="application/octet-stream"/>
                </item>
          EOF
              fi
            done < release_tags.txt
          fi
          
          cat >> appcast.xml << 'EOF'
            </channel>
          </rss>
          EOF

      - name: Upload appcast to latest release
        run: |
          if [ ! -f appcast.xml ]; then
            echo "No appcast.xml to upload"
            exit 0
          fi
          gh release upload "$LATEST_TAG" appcast.xml --clobber