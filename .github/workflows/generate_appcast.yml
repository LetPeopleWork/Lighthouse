name: Generate Appcast

on:
  release:
    types: [published]
  workflow_dispatch:

jobs:
  appcast:
    runs-on: macos-latest
    if: github.repository == 'LetPeopleWork/Lighthouse'

    permissions:
      contents: write

    env:
      GH_TOKEN: ${{ github.token }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install GitHub CLI
        run: |
          brew install gh

      - name: Install Pandoc
        run: |
          brew install pandoc

      - name: Install jq
        run: |
          brew install jq

      - name: Install Rosetta
        run: |
          softwareupdate --install-rosetta --agree-to-license

      - name: Install Sparkle
        run: |
          echo "Installing Sparkle..."
          if ! command -v sparkle &>/dev/null; then
              echo "Installing Sparkle..."
              brew install --cask sparkle
          else
              echo "Sparkle already installed."
          fi

          # Set Sparkle release version
          SPARKLE_VERSION="2.8.1"
          SPARKLE_TAR="Sparkle-${SPARKLE_VERSION}.tar.xz"
          SPARKLE_URL="https://github.com/sparkle-project/Sparkle/releases/download/${SPARKLE_VERSION}/${SPARKLE_TAR}"

          # Download Sparkle release if not already downloaded
          if [ ! -f "$SPARKLE_TAR" ]; then
              echo "Downloading Sparkle ${SPARKLE_VERSION}..."
              curl -L -O "$SPARKLE_URL"
          fi

          # Extract the binaries
          echo "Extracting Sparkle binaries..."
          tar -xf "$SPARKLE_TAR"

          # Copy helper tools to /usr/local/bin
          echo "Installing helper tools..."
          cp "Sparkle-${SPARKLE_VERSION}/bin/generate_appcast" /usr/local/bin/
          cp "Sparkle-${SPARKLE_VERSION}/bin/sign_update" /usr/local/bin/
          chmod +x /usr/local/bin/generate_appcast /usr/local/bin/sign_update

          # Verify installation
          echo "Verifying installation..."
          command -v sparkle || echo "sparkle not found in PATH"
          command -v generate_appcast || echo "generate_appcast not found in PATH"
          command -v sign_update || echo "sign_update not found in PATH"

          echo "âœ… Sparkle installation complete!"


      - name: Prepare private key
        run: |
          echo "${{ secrets.SPARKLE_PRIVATE_KEY }}" | base64 -d > private_key.pem
          chmod 600 private_key.pem

      - name: Get latest releases
        run: |
          mkdir -p updates
          # Get latest 5 non-prerelease tags
          RELEASE_TAGS=$(gh api repos/LetPeopleWork/Lighthouse/releases --jq '.[] | select(.prerelease == false) | .tag_name' | head -5)
          if [ -z "$RELEASE_TAGS" ]; then
            echo "No non-prerelease releases found, skipping appcast generation"
            exit 0
          fi
          echo "$RELEASE_TAGS" > release_tags.txt
          LATEST_TAG=$(echo "$RELEASE_TAGS" | head -1)
          echo "LATEST_TAG=$LATEST_TAG" >> $GITHUB_ENV

          cat release_tags.txt

      - name: Download DMGs and create notes
        run: |
          # Helper: try native first, then Rosetta x86_64 if available
          get_signature() {
            local dmg="$1"
            # Try sign_update from PATH
            if command -v sign_update >/dev/null 2>&1; then
              sign_update "$dmg" private_key.pem
              return 0
            fi

            # Try known locations
            if [ -x "/opt/homebrew/bin/sign_update" ]; then
              /opt/homebrew/bin/sign_update "$dmg" private_key.pem
              return 0
            fi
            if [ -x "/usr/local/bin/sign_update" ]; then
              /usr/local/bin/sign_update "$dmg" private_key.pem
              return 0
            fi

            # Try the 'sparkle' binary with likely subcommands
            if command -v sparkle >/dev/null 2>&1; then
              if sparkle sign_update "$dmg" private_key.pem >/dev/null 2>&1; then
                sparkle sign_update "$dmg" private_key.pem
                return 0
              fi
              if sparkle sign "$dmg" private_key.pem >/dev/null 2>&1; then
                sparkle sign "$dmg" private_key.pem
                return 0
              fi
            fi

            echo "ERROR: sign_update not found or failed" >&2
            file /usr/local/bin/sign_update || true
            file /opt/homebrew/bin/sign_update || true
            lipo -info /usr/local/bin/sign_update || true
            otool -L /usr/local/bin/sign_update || true
            return 1
          }

          if [ ! -f release_tags.txt ]; then
            echo "No releases to process"
            exit 0
          fi
          mkdir -p updates/dmg
          rm -f updates/dmg/manifest.csv
          while IFS= read -r tag; do
            if [ -z "$tag" ]; then continue; fi
            echo "Processing release $tag"
            # Find any DMG asset for this release (be flexible with naming)
            ASSET_NAME=$(gh release view "$tag" --json assets --jq '.assets[].name' | grep -E '\.dmg$' | head -1)
            if [ -n "$ASSET_NAME" ]; then
              echo "DMG found for $tag: $ASSET_NAME, downloading..."
              gh release download "$tag" --pattern "$ASSET_NAME" --dir updates/dmg/
              DMG_PATH="updates/dmg/$ASSET_NAME"
              # Sign the DMG (try native then Rosetta)
              if ! get_signature "$DMG_PATH" >/dev/null; then
                echo "Signing failed for $DMG_PATH"
                exit 1
              fi

              # Get release body and create HTML notes (one notes file per tag)
              RELEASE_BODY=$(gh api repos/LetPeopleWork/Lighthouse/releases/tags/"$tag" | jq -r '.body')
              NOTES_FILE="updates/notes-${tag}.html"
              if [ "$RELEASE_BODY" != "null" ] && [ -n "$RELEASE_BODY" ]; then
                echo "$RELEASE_BODY" | pandoc -f markdown -t html > "$NOTES_FILE"
              else
                echo "<p>No release notes available.</p>" > "$NOTES_FILE"
              fi

              # Record mapping of tag -> asset name for later appcast generation
              echo "${tag},${ASSET_NAME}" >> updates/dmg/manifest.csv
            else
              echo "No DMG found for $tag, skipping..."
            fi
          done < release_tags.txt

      - name: Generate appcast
        run: |
          # Helper: try native then Rosetta for sign_update
          get_signature() {
            local dmg="$1"
            # Try sign_update from PATH
            if command -v sign_update >/dev/null 2>&1; then
              sign_update "$dmg" private_key.pem
              return 0
            fi

            # Try known locations
            if [ -x "/opt/homebrew/bin/sign_update" ]; then
              /opt/homebrew/bin/sign_update "$dmg" private_key.pem
              return 0
            fi
            if [ -x "/usr/local/bin/sign_update" ]; then
              /usr/local/bin/sign_update "$dmg" private_key.pem
              return 0
            fi

            # Try the 'sparkle' binary with likely subcommands
            if command -v sparkle >/dev/null 2>&1; then
              if sparkle sign_update "$dmg" private_key.pem >/dev/null 2>&1; then
                sparkle sign_update "$dmg" private_key.pem
                return 0
              fi
              if sparkle sign "$dmg" private_key.pem >/dev/null 2>&1; then
                sparkle sign "$dmg" private_key.pem
                return 0
              fi
            fi

            echo "ERROR: sign_update not found or failed" >&2
            file /usr/local/bin/sign_update || true
            file /opt/homebrew/bin/sign_update || true
            lipo -info /usr/local/bin/sign_update || true
            otool -L /usr/local/bin/sign_update || true
            return 1
          }

          if [ ! -f release_tags.txt ]; then
            echo "No releases to process"
            exit 0
          fi
          # Generate appcast XML with real data
          cat > appcast.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle" xmlns:dc="http://purl.org/dc/elements/1.1/">
            <channel>
              <title>Lighthouse</title>
              <description>Most recent changes with links to updates.</description>
              <language>en</language>
          EOF
          
          # Use manifest mapping (tag -> asset) if available
          if [ -f updates/dmg/manifest.csv ]; then
            while IFS=, read -r tag asset; do
              if [ -z "$tag" ] || [ -z "$asset" ]; then continue; fi
              DMG_PATH="updates/dmg/${asset}"
              if [ -f "$DMG_PATH" ]; then
                RELEASE_INFO=$(gh api repos/LetPeopleWork/Lighthouse/releases/tags/"$tag")
                TITLE=$(echo "$RELEASE_INFO" | jq -r .name)
                PUB_DATE=$(echo "$RELEASE_INFO" | jq -r .published_at | sed 's/T/ /' | sed 's/Z//' | xargs -I {} date -j -f "%Y-%m-%d %H:%M:%S" {} +"%a, %d %b %Y %H:%M:%S +0000")
                BODY_HTML=$(cat "updates/notes-${tag}.html" 2>/dev/null || echo "<p>No notes</p>")
                URL="https://github.com/LetPeopleWork/Lighthouse/releases/download/${tag}/${asset}"
                SIGNATURE=$(get_signature "$DMG_PATH" 2>/dev/null)
                LENGTH=$(stat -f%z "$DMG_PATH")
                
                cat >> appcast.xml << EOF
                <item>
                  <title>$TITLE</title>
                  <sparkle:version>$tag</sparkle:version>
                  <sparkle:shortVersionString>$tag</sparkle:shortVersionString>
                  <description><![CDATA[$BODY_HTML]]></description>
                  <pubDate>$PUB_DATE</pubDate>
                  <enclosure url="$URL" sparkle:version="$tag" sparkle:edSignature="$SIGNATURE" length="$LENGTH" type="application/octet-stream"/>
                </item>
          EOF
              fi
            done < updates/dmg/manifest.csv
          else
            # Fallback: look for dmg files matching tag in updates/dmg/
            while IFS= read -r tag; do
              if [ -z "$tag" ]; then continue; fi
              DMG_PATH=$(ls updates/dmg/*"${tag}"*.dmg 2>/dev/null | head -1)
              if [ -f "$DMG_PATH" ]; then
                ASSET=$(basename "$DMG_PATH")
                RELEASE_INFO=$(gh api repos/LetPeopleWork/Lighthouse/releases/tags/"$tag")
                TITLE=$(echo "$RELEASE_INFO" | jq -r .name)
                PUB_DATE=$(echo "$RELEASE_INFO" | jq -r .published_at | sed 's/T/ /' | sed 's/Z//' | xargs -I {} date -j -f "%Y-%m-%d %H:%M:%S" {} +"%a, %d %b %Y %H:%M:%S +0000")
                BODY_HTML=$(cat "updates/notes-${tag}.html" 2>/dev/null || echo "<p>No notes</p>")
                URL="https://github.com/LetPeopleWork/Lighthouse/releases/download/${tag}/${ASSET}"
                SIGNATURE=$(get_signature "$DMG_PATH" 2>/dev/null)
                LENGTH=$(stat -f%z "$DMG_PATH")
                
                cat >> appcast.xml << EOF
                <item>
                  <title>$TITLE</title>
                  <sparkle:version>$tag</sparkle:version>
                  <sparkle:shortVersionString>$tag</sparkle:shortVersionString>
                  <description><![CDATA[$BODY_HTML]]></description>
                  <pubDate>$PUB_DATE</pubDate>
                  <enclosure url="$URL" sparkle:version="$tag" sparkle:edSignature="$SIGNATURE" length="$LENGTH" type="application/octet-stream"/>
                </item>
          EOF
              fi
            done < release_tags.txt
          fi
          
          cat >> appcast.xml << 'EOF'
            </channel>
          </rss>
          EOF

      - name: Upload appcast to latest release
        run: |
          if [ ! -f appcast.xml ]; then
            echo "No appcast.xml to upload"
            exit 0
          fi
          gh release upload "$LATEST_TAG" appcast.xml --clobber